Document 4: Database Schema Document (Revised)
File Name: docs/database-schema-v1.3.md
Version: 1.3
Date: June 8, 2025
Purpose: Specifies the database schema for PostgreSQL (using Drizzle ORM and pgvector extension on a managed service like Neon). This document guides AI-assisted development in generating schema definitions, migrations, queries, and vector storage logic for the RAG Chatbot Platform's enhanced MVP.
Table of Contents
Overview
1.1. Database System (Managed PostgreSQL with pgvector)
1.2. ORM (Drizzle ORM)
1.3. General Schema Design Principles
PostgreSQL Schema (Drizzle ORM Definitions)
2.1. Naming Conventions
2.2. Common Columns & updatedAt Handling
2.3. Enum Types (Drizzle pgEnum)
2.4. users Table
2.5. plans Table (for SaaS Tiers)
2.6. tenant_settings Table (for BYOK LLM Keys & Tenant Configs)
2.7. bots Table
2.8. bot_prompts Table
2.9. bot_documents Table
2.10. bot_document_chunks Table (with pgvector Embeddings)
2.11. widget_configurations Table
2.12. templates Table
2.13. analytics_query_logs Table
2.14. analytics_feedback Table
Relationships and Foreign Keys Summary
Indexing Strategy (Including pgvector Indexes)
Migrations (Drizzle Kit)
pgvector Specifics
6.1. Embedding Dimension
6.2. Distance Metrics
6.3. Indexing (hnsw or ivfflat)
6.4. Conceptual Querying
Future Scalability Considerations (Partitioning)
Data Integrity & Consistency Notes
Data Retention and Archival Overview
1. Overview
1.1. Database System (Managed PostgreSQL with pgvector)
Database System: PostgreSQL (v16+ or a compatible version offered by the managed provider, ensuring pgvector extension compatibility).
Managed Provider Example: Neon (Serverless Postgres with easy pgvector extension enablement). Alternatives include Railway, Fly.io Postgres, Supabase DB-only.
Key Extension: pgvector (version 0.5.0+ recommended for HNSW support) for storing and searching vector embeddings efficiently.
Purpose: Central data store for all relational application data (users, bots, configurations, analytics metadata) and vector data (document chunk embeddings for RAG).
1.2. ORM (Drizzle ORM)
ORM: Drizzle ORM for TypeScript.
Migrations: drizzle-kit for generating and managing SQL migration files.
Purpose: Provides type-safe SQL query building, schema definition (as code), and a robust migration workflow.
1.3. General Schema Design Principles
Data normalization is applied to reduce redundancy and improve data integrity (generally aiming for 3NF where practical for core entities).
UUIDs (uuid type in PostgreSQL, generated by gen_random_uuid()) are used for primary keys of most tables for global uniqueness.
Consistent timestamping (createdAt, updatedAt using timestamp with time zone) for all mutable entities.
Foreign key constraints are used to enforce relational integrity between tables, with appropriate onDelete and onUpdate behaviors.
Strategic use of indexes (B-tree, GIN, HNSW/IVFFlat for pgvector) to optimize query performance.
Use of PostgreSQL native enum types (via Drizzle's pgEnum) for columns with a fixed, predefined set of string values to ensure data integrity and type safety.
2. PostgreSQL Schema (Drizzle ORM Definitions)
(Conceptual Drizzle ORM TypeScript definitions. Includes necessary imports and assumes enums might be in a shared file.)
2.1. Naming Conventions
Tables: snake_case, plural (e.g., users, bot_prompts).
Columns (in Drizzle definition): camelCase (conventionally maps to snake_case in the database, e.g., createdAt becomes created_at).
Primary Keys: id (UUID).
Foreign Keys: {referencedTableSingular}_id (e.g., user_id, bot_id).
2.2. Common Columns & updatedAt Handling
id: uuid('id').primaryKey().defaultRandom() - Standard for most tables.
createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull() - Standard for most tables.
updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()) - Drizzle helper to automatically update this timestamp on row modification. Used for mutable entities.
2.3. Enum Types (Drizzle pgEnum)
import { pgEnum } from 'drizzle-orm/pg-core';

// User related enums
export const userRoleEnum = pgEnum('user_role_enum', ['USER', 'ADMIN']);
export const userStatusEnum = pgEnum('user_status_enum', ['ACTIVE', 'PENDING_VERIFICATION', 'SUSPENDED']);
export const authProviderEnum = pgEnum('auth_provider_enum', ['email', 'google', 'github']);

// Bot and Document related enums
export const botStatusEnum = pgEnum('bot_status_enum', ['CREATING', 'PROCESSING_DOCUMENTS', 'READY', 'ERROR', 'UPDATING']);
export const botDocumentStatusEnum = pgEnum('bot_document_status_enum', ['PENDING', 'PROCESSING', 'PROCESSED', 'FAILED']);
export const documentSourceTypeEnum = pgEnum('document_source_type_enum', ['FILE_UPLOAD', 'MANUAL_TEXT', 'JSON_STRUCTURED', 'CSV_STRUCTURED']); // For PRD v1.3

// LLM related enums
export const llmProviderEnum = pgEnum('llm_provider_enum', ['openai', 'anthropic', 'grok', 'ollama']); // Example, extend as needed
Use code with caution.
TypeScript
2.4. users Table
import { pgTable, uuid, varchar, timestamp, text, boolean, uniqueIndex } from 'drizzle-orm/pg-core';
import { userRoleEnum, userStatusEnum, authProviderEnum } from './enums'; // Assuming enums are in './enums.ts'
import { plans } from './plans'; // Assuming plans table is defined in './plans.ts'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  hashedPassword: text('hashed_password'), // Nullable for OAuth users
  name: varchar('name', { length: 255 }),
  image: text('image_url'), // URL for OAuth profile picture
  authProvider: authProviderEnum('auth_provider').default('email').notNull(),
  role: userRoleEnum('role').default('USER').notNull(),
  status: userStatusEnum('status').default('PENDING_VERIFICATION').notNull(),
  emailVerified: boolean('email_verified').default(false).notNull(),
  lastLoginAt: timestamp('last_login_at', { withTimezone: true }),
  planId: uuid('plan_id').references(() => plans.id, { onDelete: 'set null' }), // Link to SaaS plan
  // 2FA fields (twoFactorSecret, twoFactorEnabled) are deferred to Post-MVP
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    emailIdx: uniqueIndex('idx_users_email').on(table.email), // Drizzle creates unique constraint too
  };
});
Use code with caution.
TypeScript
2.5. plans Table (for SaaS Tiers)
import { pgTable, uuid, varchar, text, decimal, integer, boolean, timestamp, uniqueIndex } from 'drizzle-orm/pg-core';

export const plans = pgTable('plans', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 100 }).notNull().unique(),
  description: text('description'),
  priceMonthly: decimal('price_monthly', { precision: 10, scale: 2 }).default('0.00'),
  maxBots: integer('max_bots').default(1).notNull(),
  maxDocumentsPerBot: integer('max_documents_per_bot').default(5).notNull(),
  maxTotalDocumentStorageGB: real('max_total_document_storage_gb').default(1.0).notNull(), // Using real for GB
  maxQueriesPerMonth: integer('max_queries_per_month').default(1000).notNull(),
  maxDocProcessingJobsPerMonth: integer('max_doc_processing_jobs_per_month').default(10).notNull(),
  allowAdvancedRagConfig: boolean('allow_advanced_rag_config').default(false).notNull(),
  isActive: boolean('is_active').default(true).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    nameIdx: uniqueIndex('idx_plans_name').on(table.name),
  };
});
Use code with caution.
TypeScript
2.6. tenant_settings Table (for BYOK LLM Keys & Tenant Configs)
// ... imports, users, llmProviderEnum
export const tenantSettings = pgTable('tenant_settings', {
  tenantId: uuid('tenant_id').primaryKey().references(() => users.id, { onDelete: 'cascade' }), // Assumes user IS the tenant for MVP
  llmProvider: llmProviderEnum('llm_provider'),
  llmApiKeyEncrypted: text('llm_api_key_encrypted'), // Application-level encrypted ciphertext
  embeddingProvider: llmProviderEnum('embedding_provider'), // If different embedding API used
  embeddingApiKeyEncrypted: text('embedding_api_key_encrypted'), // Application-level encrypted
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
});
Use code with caution.
TypeScript
2.7. bots Table
// ... imports, users, templates, botStatusEnum, jsonb, llmProviderEnum
import { botPrompts } from './botPrompts'; // Assuming defined in './botPrompts.ts'

export const bots = pgTable('bots', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  templateId: uuid('template_id').references(() => templates.id, { onDelete: 'set null' }),
  name: varchar('name', { length: 255 }).notNull(),
  description: text('description'),
  publicUrlId: varchar('public_url_id', { length: 32 }).notNull().unique(), // For public chat links
  ragConfig: jsonb('rag_config').notNull().$type<RagConfigOutput>().default({ chunkSize: 500, overlap: 50, topK: 3 }), // RAG params only
  activePromptId: uuid('active_prompt_id').references(() => botPrompts.id, { onDelete: 'set null' }), // Active system prompt
  activeLlmConfigProvider: llmProviderEnum('active_llm_config_provider'), // Which user's BYOK provider to use
  status: botStatusEnum('status').default('CREATING').notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    publicUrlIdIdx: uniqueIndex('idx_bots_public_url_id').on(table.publicUrlId),
  };
});
Use code with caution.
TypeScript
2.8. bot_prompts Table
// ... imports, bots
export const botPrompts = pgTable('bot_prompts', {
  id: uuid('id').primaryKey().defaultRandom(),
  botId: uuid('bot_id').notNull().references(() => bots.id, { onDelete: 'cascade' }),
  name: varchar('name', { length: 255 }).notNull(),
  content: text('content').notNull(), // The actual system prompt text
  isActive: boolean('is_active').default(false).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    // Optional: Unique constraint for prompt name per bot. Application logic can also enforce this.
    uniqueNamePerBotIdx: uniqueIndex('idx_bot_prompts_bot_id_name').on(table.botId, table.name),
  };
});
Use code with caution.
TypeScript
2.9. bot_documents Table
// ... imports, bots, botDocumentStatusEnum, documentSourceTypeEnum
export const botDocuments = pgTable('bot_documents', {
  id: uuid('id').primaryKey().defaultRandom(),
  botId: uuid('bot_id').notNull().references(() => bots.id, { onDelete: 'cascade' }),
  fileName: varchar('file_name', { length: 255 }).notNull(), // User-defined name or actual file name
  sourceType: documentSourceTypeEnum('source_type').notNull().default('FILE_UPLOAD'),
  fileType: varchar('file_type', { length: 100 }), // MIME type for FILE_UPLOAD (e.g., application/pdf, text/csv, application/json)
  fileSize: integer('file_size'), // bytes, for FILE_UPLOAD or calculated for text
  storagePath: text('storage_path').unique(), // Cloudflare R2 object key (FILE_UPLOAD) or internal identifier for manual/structured
  status: botDocumentStatusEnum('status').default('PENDING').notNull(),
  errorMessage: text('error_message'),
  chunkCount: integer('chunk_count').default(0), // Populated after chunking
  processedAt: timestamp('processed_at', { withTimezone: true }),
  uploadedAt: timestamp('uploaded_at', { withTimezone: true }).defaultNow().notNull(), // Time of upload or manual creation
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    storagePathIdx: uniqueIndex('idx_bot_documents_storage_path').on(table.storagePath),
  };
});
Use code with caution.
TypeScript
2.10. bot_document_chunks Table (with pgvector Embeddings)
import { customType, pgTable, uuid, text, integer, timestamp } from 'drizzle-orm/pg-core'; // Ensure all Drizzle types are imported
import { bots } from './bots';
import { botDocuments } from './botDocuments';

// Define the vector type based on your chosen embedding dimension (e.g., 768 for many models like text-embedding-3-small or nomic-embed-text)
const embeddingDimension = 768; // This MUST match the output dimension of your embedding model
const vectorType = customType<{ data: number[]; mode: 'vector' }>({
    dataType() {
        return `vector(${embeddingDimension})`;
    },
    toDriver(value: number[]): string { // How to convert JS array to PGvector string format for insertion
        return `[${value.join(',')}]`;
    },
    // fromDriver is optional if you don't read the raw vector back often, or handle it in application.
});

export const botDocumentChunks = pgTable('bot_document_chunks', {
  id: uuid('id').primaryKey().defaultRandom(),
  botId: uuid('bot_id').notNull().references(() => bots.id, { onDelete: 'cascade' }),
  documentId: uuid('document_id').notNull().references(() => botDocuments.id, { onDelete: 'cascade' }),
  chunkText: text('chunk_text').notNull(),
  embedding: vectorType('embedding').notNull(), // Stores the vector embedding
  chunkIndex: integer('chunk_index').notNull(),
  // Any other metadata specific to this chunk can be added here if needed
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
});
Use code with caution.
TypeScript
2.11. widget_configurations Table
// ... imports, bots
export const widgetConfigurations = pgTable('widget_configurations', {
  botId: uuid('bot_id').primaryKey().references(() => bots.id, { onDelete: 'cascade' }), // One-to-one with bots
  headerText: varchar('header_text', { length: 100 }).default('Chat Assistant').notNull(),
  primaryColor: varchar('primary_color', { length: 7 }).default('#007bff').notNull(), // Default hex color
  initialGreeting: text('initial_greeting').default('Hello! How can I help you today?').notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
});
Use code with caution.
TypeScript
2.12. templates Table
// ... imports, jsonb
export const templates = pgTable('templates', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 255 }).notNull().unique(),
  description: text('description'),
  category: varchar('category', { length: 100 }),
  defaultRagConfig: jsonb('default_rag_config').notNull().$type<RagConfigOutput>().default({ chunkSize: 500, overlap: 50, topK: 3 }),
  sampleSystemPrompt: text('sample_system_prompt'),
  sampleQueries: jsonb('sample_queries').$type<string[]>(), // Array of strings
  iconUrl: text('icon_url'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()),
}, (table) => {
  return {
    nameIdx: uniqueIndex('idx_templates_name').on(table.name),
  };
});
Use code with caution.
TypeScript
2.13. analytics_query_logs Table
// ... imports, bots, users, llmProviderEnum
export const analyticsQueryLogs = pgTable('analytics_query_logs', {
  id: uuid('id').primaryKey().defaultRandom(),
  botId: uuid('bot_id').notNull().references(() => bots.id, { onDelete: 'cascade' }),
  queryingUserId: uuid('querying_user_id').references(() => users.id, { onDelete: 'set null' }), // User who interacted via platform
  sessionId: varchar('session_id', { length: 255 }), // For distinct chat sessions (platform or widget)
  queryText: text('query_text').notNull(),
  llmModelUsed: varchar('llm_model_used', { length: 100 }), // Actual model identifier from provider
  llmProviderUsed: llmProviderEnum('llm_provider_used'), // Which provider was used
  responseTimeMs: integer('response_time_ms'),
  sourceDocumentsCount: integer('source_documents_count').default(0),
  inputTokens: integer('input_tokens'), // For cost tracking / analytics
  outputTokens: integer('output_tokens'), // For cost tracking / analytics
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
});
Use code with caution.
TypeScript
2.14. analytics_feedback Table
// ... imports, analyticsQueryLogs
export const analyticsFeedback = pgTable('analytics_feedback', {
  id: uuid('id').primaryKey().defaultRandom(),
  queryLogId: uuid('query_log_id').notNull().references(() => analyticsQueryLogs.id, { onDelete: 'cascade' }).unique(),
  rating: integer('rating').notNull(), // e.g., 1 for positive (thumbs up), -1 for negative (thumbs down)
  comment: text('comment'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull().$onUpdate(() => new Date()), // If comments are editable
});
Use code with caution.
TypeScript
3. Relationships and Foreign Keys Summary
users.planId → plans.id (Many-to-One, onDelete: 'set null')
tenant_settings.tenantId → users.id (One-to-One, onDelete: 'cascade')
bots.userId → users.id (Many-to-One, onDelete: 'cascade')
bots.templateId → templates.id (Many-to-One, onDelete: 'set null')
bots.activePromptId → bot_prompts.id (Many-to-One, onDelete: 'set null')
bot_prompts.botId → bots.id (Many-to-One, onDelete: 'cascade')
bot_documents.botId → bots.id (Many-to-One, onDelete: 'cascade')
bot_document_chunks.botId → bots.id (Many-to-One, onDelete: 'cascade')
bot_document_chunks.documentId → bot_documents.id (Many-to-One, onDelete: 'cascade')
widget_configurations.botId → bots.id (One-to-One, onDelete: 'cascade')
analytics_query_logs.botId → bots.id (Many-to-One, onDelete: 'cascade')
analytics_query_logs.queryingUserId → users.id (Many-to-One, onDelete: 'set null')
analytics_feedback.queryLogId → analytics_query_logs.id (One-to-One, onDelete: 'cascade')
4. Indexing Strategy (Including pgvector Indexes)
users: email (unique), planId, role, status, authProvider.
plans: name (unique).
tenant_settings: tenantId (PK).
bots: userId, templateId, status, publicUrlId (unique), activePromptId, activeLlmConfigProvider.
bot_prompts: (botId, isActive), (botId, name) (if unique per bot).
bot_documents: (botId, sourceType, status), storagePath (unique).
bot_document_chunks: botId, documentId.
pgvector Index (HNSW example): CREATE INDEX ON bot_document_chunks USING hnsw (embedding vector_cosine_ops); (or vector_l2_ops, vector_ip_ops depending on normalization and distance metric). This is critical and created via custom SQL in a Drizzle migration.
widget_configurations: botId (PK).
templates: name (unique), category.
analytics_query_logs: (botId, createdAt DESC), queryingUserId, sessionId, llmProviderUsed, (input_tokens + output_tokens) (if querying by total tokens).
analytics_feedback: queryLogId (unique).
5. Migrations (Drizzle Kit)
Schema changes are defined in TypeScript using Drizzle ORM syntax.
SQL migration files are generated using drizzle-kit generate:pg.
Migrations are applied to the database (local, staging Neon, production Neon) using drizzle-kit push:pg (for dev/simple cases) or a migration execution script (e.g., npm run db:migrate) for more control in CI/CD.
6. pgvector Specifics
Embedding Dimension: The embeddingDimension constant (e.g., 768) used in bot_document_chunks schema MUST match the output dimension of the embedding model(s) used by the application.
Distance Metrics: Choose an appropriate distance metric for similarity search (e.g., vector_cosine_ops for normalized embeddings, vector_l2_ops for Euclidean distance, vector_ip_ops for inner product). This is specified during index creation.
Indexing (hnsw or ivfflat): HNSW is generally recommended for a good balance of search speed and accuracy for approximate nearest neighbor search. IVFFlat can also be used but requires a lists parameter and "training" (building the index). Index parameters (e.g., m, ef_construction for HNSW) and query-time parameters (hnsw.ef_search for HNSW; ivflist.probes for IVFFlat) will need tuning.
Conceptual Querying: Use Drizzle's sql tag for vector operations.
// import { sql } from 'drizzle-orm';
// const queryVectorString = `[${queryVectorArray.join(',')}]`;
// const similarChunks = await db.execute(sql`
//   SELECT id, chunk_text, document_id, embedding <=> ${queryVectorString}::vector AS distance
//   FROM bot_document_chunks
//   WHERE bot_id = ${botId}
//   ORDER BY distance ASC
//   LIMIT ${topK}
// `);
Use code with caution.
TypeScript
7. Future Scalability Considerations (Partitioning)
analytics_query_logs and bot_document_chunks are the tables most likely to grow very large. For long-term scalability beyond the MVP, consider PostgreSQL table partitioning (e.g., by createdAt month/quarter for logs, or by botId range for chunks if some bots become extremely large).
8. Data Integrity & Consistency Notes
Utilize PostgreSQL transactions within the application layer (tRPC API) for operations that modify multiple related tables to ensure atomicity.
Application logic is responsible for managing eventual consistency with external services like Cloudflare R2 (file uploads) and Inngest/Trigger.dev (async job status reflected in bot_documents.status).
9. Data Retention and Archival Overview
User, bot, prompt, document, and widget configuration data is retained as long as the parent entities (user, bot) are active. Deletion cascades are defined by foreign key constraints (e.g., deleting a bot deletes its prompts, documents, chunks, widget config, analytics).
Analytics data (analytics_query_logs, analytics_feedback) may be subject to periodic aggregation or archival policies in the future to manage table size while retaining historical insights.
Backups are primarily handled by the managed database provider (Neon), leveraging their PITR and snapshot capabilities. Understand and configure their retention policies.